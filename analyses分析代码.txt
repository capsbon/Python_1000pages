ruby 中yield可以起到占位的 作用

先在某部分代码前用yield占住位置，然后在接下来的某个代码块里实现它

ci = ConfigDefectAnalysis::CaseInquirer.new({:pluspath => pluspath})
创建CaseInquirer类的实例并传入pluspath参数，
其中CaseInquirer继承于SymptomExtractor类
执行的方法有SymptomExtractor类的initialize(arags），init_optionparser2（args)，还有CaseInquirer类的initialize方法。

StringIO用于在内存中读写字符串
ci.init(csvpath)
先执行父类symptom_extractor.rb中的init方法，其中先后执行prepare_local()方法和print_pkgdbinfo()方法，其中preare_local调用parse_rpm_qail方法对rpm文件进行分析处理（从分析内容中判断所处平台，是富士通中间件还是系统log），print_pkgdbinfo（）打印出@pkgdb哈希的长度
传入学习文件路径，对学习文件路径下的output_cases.csv和output_stats.csv以及output_failedpaths.csv进行处理

ci.parse()

调用SymptomExtractor类中的parse方法，parse中只含有parse_tar一个方法，
parse_tar方法首先判断上传文件是否存在，然后根据操作系统类型选择解压方式，再调用initrpm和extract_symptom方法。initrpm主要是处理解压后文件夹中的/commands/rpm_qail文件
然后执行extract_symptom方法，

ruby中concat方法：用于连接连接多个数组，结果返回一个包含两个数组元素的新数组，array.concat(arrayB) 相当于 array + arrayB

数组中push方法用于向数组尾部添加元素，array.push("element1","element2")

ruby中数组的pop方法从数组组移除最后一个元素，并返回这个元素
str.downcase 把字符串中的大写字母转化成小写字母并返回

convert_logs：主要对上传的txt文件进行逐行读取分析处理，和filepath,msgtype等一起传入msgPatterns数组并返回
get_logs():获取logpatn下的 文件路径并保存到result中返回，结果赋给paths
在extract_symptom中遍历paths，判断type是系统log还是富士通中间件log
get_error_messages():根据get_logs()里获得的type判断parser是@syslogparser还是@fjmwlog调用相应的does方法进行处理
does():对messagePatterns进行遍历，验证msgtype和msgsubtype，然后把path，datetime，hostname，data，id，software等传给fragment实例并返回

analyze_symptom():传入fragment.path,fragment.id以及fragment，结果返回哈希symptom，传入case_inquirer.rb中的inquire（）中，得到results，scores。
case_inquirer.rb的extract_symptom方法：主要是把分析得到的@all_results,@all_scores写入到result.csv文件中
python中list的reverse()方法对列表的元素进行反向排序，没有返回值，result = list.reverse(),打印出来result为None
python中构造二维数组不能简单的alist =[][]
需要Matrix = [[0 for x in range(w)] for y in range(h)] 
或者先建立一个一维数组，然后向其中赋列表类型的值，g = [0]*10
for i in range(10):
    g[i] = [0]*3
	
	
	
	
Wu_O(NP)算法理解：
主要是利用delta（两字符串长度差）+p(损失度）*2 来计算编辑距离D
确定起始点S：
-p <= k <delta:
S = max(与p相同的k-1线上的y坐标+1，比p少1的k+1线上的y坐标）
k = delta:
S = max(与p相同的k-1线上的y坐标+1，与p相同的k+1线上的y坐标）
delta < k <= delta+p:
S = max(比p小1的k-1线上的y坐标+1,与p相同的k+1线上的y坐标)
到终点时确定fp[delta,p]
利用D = delta + p * 2 计算出经过的编辑距离

windows安装anaconda3以及一些库：
1.如果已经装了python请先卸载
2.安装anaconda3-4.2.0-Windows-x86_64.exe（在百度云anaconda里）。
3.查看需要安装的库是否存在
· Numpy
. Scipy
. Pandas
. Matplotlib
. Sklearn
以上anaconda中已经存在，安装以下两个即可：
. Keras
. Tensorflow
4.安装keras：
cmd 命令行下执行:
pip install keras

5.安装tensorflow （cpu版本）：
pip install --upgrade --ignore-installed tensorflow

注意：
1.查看这些库是否存在，进入python环境后import 库名 即可
2.import keras时出现
AttributeError: module 'pandas' has no attribute 'computation'错误
原因是dask版本需要升级，执行以下命令即可：
conda update dask


matplotlib库：一个强大的python画图工具，提供数据图形化功能
sklearn（Scikit learn）：用于数据挖掘和数据分析，是机器学习中常用的python库
keras：建立在Tensorflow 和Theano 之上的深度学习框架，是Tensorflow 和Theano的API
tensorflow：谷歌开源的深度学习系统

人工智能，机器学习和深度学习的区别：人工智能包括机器学习，机器学习包括深度学习；
机器学习是实现人工智能的一种方式，深度学习是机器学习中生物科学神经网路和计算机科学数据分析结合的新领域。

使用tensorflow时出现“The TensorFlow library wasn't compiled to use AVX instructions, but these are available on your machine and could speed up CPU computations.”信息，只是提醒你tensorflow可以对你的cpu进行优化加速，不想出现提醒信息加上
import os
os.environ['TF_CPP_MIN_LOG_LEVEL']='2'
两句即可


泛化能力是指训练好的模型在未见过的数据上的表现
机器学习算法中，经常把原始数据分为三类：training data（训练数据）；validation data（验证数据），testing data(测试数据）。其中validation用来避免过拟合
ai rl dl
lr 逻辑回归
朴素贝叶斯
线性代数
概率论
数据计算
 支持向量机（svm ，support vector machine)是一种用于分类的机器学习算法
 神经网络
 什么特征做决策

 
 ai 算法实现 特征选择 数据 
 神经网络的实现大多需要做矩阵计算 
 分布式并行处理使用gpu会快很多
 逻辑回归是做分类的
 svm random f gbdt
 dnn cnn rnn
 随机森林（Random Forests）：可以理解为低配版的gbdt
 GBDT(Gradient Boosting Decision Tree) ：一种迭代的决策树算法，通过构造一组弱的学习器（树），并把多颗决策树的结果累加起来作为最终的预测输出。
 
 过拟合（overfitting，导致泛化能力差）最佳解决办法：增加数据量
 
 全连接神经网络： 不太适合图像处理，参数数量太多，网络层数少。
 卷积神经网络(Convolutional Neural Network, CNN)（擅长处理图像数据）
 循环神经网络(Recurrent Neural Network)（用于序列数据，有记忆效应，一般与lstm结合使用）
 lstm：Long Short-Term Memory长短期记忆，时间递归神经网络

 
 keras的核心数据结构是“模型”，常用的简单模型是Sequential模型，这是一系列网络层按顺序组成的栈
loss是训练集损失值.  acc是训练集准确率。val_loss是测试集上的损失值，val_acc是测试集上的准确率



监督式学习（Supervised learning):可以从训练资料中学到或建立一个模式，并以此模式推断心得实例
非监督是学习（Unsupervised learning):直接对输入的数据集进行建模，比如聚类

训练集:训练模型，确定模型参数，验证集：做模型选择。测试集：测试讯号好的模型性能。一个典型的划分是训练集占总样本的50％，而其它各占25％，三部分都是从样本中随机抽取。

batch_size 每批处理的样本个数
epochs 迭代次数

tensor（张量）：n维数组，flow：数据流图的计算，tensorflow：张量从图的一端流动到另一端



运行zabbix工具时出现PHP: Call to undefined function mb_strlen() - on custom compiled PHP with mbstring enabled
需要修改   ；extension=php_mbstring.dll
为
extension=php_mbstring.dll

php中的注释 
// 单行注释（同c/c++/c#/java/javascript）
# 单行注释（同pyhton/ruby/bash）
/* 
多行注释（同c/c++/c#/java/javascript）
*/
python多行注释（三个单引号或者双引号）
'''
注释的内容
'''
或者
"""
注释内容
"""
ruby多行注释
=begin
我是注释
=end

<!-- 我是html的注释  -->


用input_MakeFilterRule登陆，再用sample更新就会卡到 making items key and name

羽绒服*2（必选）+内衣*2+鞋子*1+袜子*1+外套*1+长裤*1（可选）+ 毛衣（可选）

关于php中截取字符串：有mb_substr()和mb_strcut()函数
其中mb_substr是按字来切分字符，mb_strcut是按字节来切分

关于mb_strlen()和strlen()的区别：
strlen()进行计算时，一个中文字符是3个长度，一个英文字符是一个长度
而mb_strlen()对于中英文都是一个字符

mb_strlen并不是PHP核心函数，使用前需要确保在php.ini中加载了php_mbstring.dll，即确保“extension=php_mbstring.dll”这一行存在并且没有被注释掉


修改fiat/__init__.py 134 行来增加或减少api

在FIAT上新增API：
1.
首先在修改fiat目录下的__init__文件，加两行
from fiat.myapi.analysis_api import CollectData
api.add_resource(CollectData, '/v1/collect_data')
其中CollectData在在analysis_api.py下新建的类
2.
在analysis_api.py下新增CollectData类
对于收集数据的api 参考admin_pages.py的233行左右

         ^
运行动作model时出现
SyntaxError: (unicode error) 'unicodeescape' codec can't decode bytes in position 2-3: truncated \UXXXXXXXX escape这个错误
主要会在python3出现这个问题，主要与文件路径的书写有关，python3里路径需要用"\\"来代替"\"
比如路径要写成这样   
filePath = "C:\\User\\Desktop\\myFile"或者
filepath = r'C:\\User\\Desktop\\myFile'
在python2里 "\"是不会出错的

动作model的构建主要是由relationsCreator类里的generateRelations()方法来实现。
generateRelations(self, conf, data, targetName)
以api中RelationsCreat为例，传入其中的三个参数conf分别是BuildConfig类的对象bulidConfig；InputAnalyser里的getData方法的返回值data数组（包含node的起始点，类型，名字，错误资源，类型等）；targetName（アクセス先的名字）

InputAnalyser里的getdata()方法：inputDir：就是需要构建关系的json文件所在的文件夹路径（我这里是FIATv2-FIAT_V2.0_API\fiat\data_source\test3），再调用getDataFromJson()方法。
getDataFromJson()：生成data数组的主要方法，主要是从（我这里是）"\fiat\data_source\test3\relation_2017-11-03_132047.json"里解析并获取数据，把type,src,dst,resource等保存到data数组里，供generateRelations()使用。

Flask-RESTful中的


FIAT中analysis_api文件上传的过程：
首先选取需要上传的文件，由于之前设置的filename的type为werkzeug.datastructures.FileStorage，所以上传的文件会保存在werkzeug.datastructures.FileStorage类中，该类有特定的几个方法，属性。这次只用到了filename属性，read()方法。
首先通过filename该属性创建与上传文件同名的文件，然后将利用read()方法读取到的二进制文件写入到刚才创建的空文件里，最后关闭这个操作。
2.
调用werkzeug.datastructures.FileStorage类的read()方法
后获得的是二进制数据，所以我们需要将其写入到新文件中
将二进制写入文件的过程;
f = open(file,"wb")  # new a file
f.write(binaryData)  #write binary data to file
f.close
上传过程中数次新建文件后写入不了，新文件为空，后修改为其他路径后即可，再改回来仍可，原因不明，可能是前期路径格式有误


改路径，改chdir目录，去掉无效注释，creat加e

model_constructor type类型

代开远程控制程序
win键+R -》  mstsc.exe


python TypeError: 'type' object is not subscriptable 

'str' object is not callable

python内置列表排序函数：
sorted(a)   # 将a从小到大排序,不影响列表a内部结构
a.sort()    # 将a从小到大排序,a列表已改变
b = a.sort()是错误的写法

Python报错：TypeError: 'str' object is not callable
原因：不要用python你饿不已有的变量和函数名作为变量名
比如str = str(i)
就会报错

NameError: name 'raw_input' is not defined
python3中 raw_input() 变成了 input()

检查json文件中type是否在allowtypelist是在input_analyser.py87行左右（支持VM类型的读入，验证代码（当前只支持四种））

depend关系relations_creator.py文件317行（验证代码(当前值支持depend关系下的cpu和disk)
->如何进行扩展）
generateRelations()98行到180行是传入csv文件的

input_analyser.py 57行附近getDataFromJson方法（点与点之间依赖关系的读入template.json）

python 中__name__ = '__main__'的作用
Make a script both importable and executable
写的代码既可以导入到别的模块中使用，也可以自己执行，方便用来调试

高并发：
前端:异步请求+资源静态化+cdn
后端:请求队列+轮询分发+负载均衡+共享缓存
数据层:redis缓存+数据分表+写队列
存储:raid阵列+热备
网络:dns轮询+DDOS攻击防护

python中mkdir和makedirs区别
mkdir( path [,mode] )
      作用：创建一个目录，可以是相对或者绝对路径，mode的默认模式是0777。
      如果目录有多级，则创建最后一级。如果最后一级目录的上级目录有不存在的，则会抛出一个OSError。

makedirs( path [,mode] )
      作用： 创建递归的目录树，可以是相对或者绝对路径，mode的默认模式也是0777。
      如果子目录创建失败或者已经存在，会抛出一个OSError的异常，Windows上Error 183即为目录已经存在的异常错误。如果path只有一级，与mkdir一样。

关于统计程序运行时间有time.time()和time.clock()两种方法，区别：
Windows中最好使用clock()函数，而在其他平台上最好使用time.time()

python列表去重
ids = list(set(ids))

python中lambda的理解：
lambda定义了一个匿名函数，可以定义简单的函数，避免制造只使用一两次且只有数行的小函数
用法 g = lambda x:x+1
则g(1) =2;g（3）=4

itertools count(1)

python中的map reduce

python 3.0.0.0以后, reduce已经不在built-in function里了, 要用它就得from functools import reduce.

python中splitlines()按行分割字符串，返回值是一个列表，如果需要保留换行符，把其中参数设为True即可splitlines(True)
split()默认按空格分割字符串，返回一个列表

python中read(),readlines,readline():
read():读完文件所有内容，返回字符串
readline():只读完一行内容，返回字符串
readlines():按行读取所有内容，返回一个列表

python中的strip()方法，str.strip([chars])用于移除字符串中指定的字符

relations_creator.py新增genMatrixApi方法和generateRelationsApi
relation_template_manager.py 中新增了loadTemplateApi（）方法
input_analyser新增了getDataApi()方法和getDataFromJsonApi()方法

$(document).ready(function(){})可以简写成$(function(){});
$(document).ready(function() {....})，即在页面加载完成后才执行某个函数

经常见到javascript里的$
$其实是一个函数名，就是用来获取部件里面的值
$()= document.getElementById()

D3js
text操作符，对所有被选择的textContent属性进行赋值
tick事件：每个时刻都要调用它进行内容的更新。一般只需要更新节点坐标即可。

d3.select()：是选择所有指定元素的第一个
d3.selectAll()：是选择指定元素的全部
append()：在选择集末尾插入元素


报KeyError错误：
使用a[key]这种方式从字典中获取一个值时，若字典中不存在这个此key时就会产生一个KeyError的错误
def foo(*args, **kwargs)中的*args, **kwargs的含义:
*args 表示任何多个无名参数，它是一个tuple；**kwargs 表示关键字参数，它是一个dict。并且同时使用*args和**kwargs时，必须*args参数列要在**kwargs前

python中的装饰器@classmethod和@staticmethod：
一般来说，如果需要使用某个类的方法，需要先实例化再调用，而使用@staticmethod或@classmethod，就可以不需要实例化，直接类名.方法名()来调用。
@staticmethod不需要表示自身对象的self和自身类的cls参数，就跟使用函数一样。
@classmethod也不需要self参数，但第一个参数需要是表示自身类的cls参数
np.nonzero函数是numpy中用于得到数组array中非零元素的位置（数组索引）的函数


确定args['type']：新建一个展示type的api?
参数是否添加 输入 template.json 的输入框
type需要template来确定或者从生成的动作model中获取
动作model中只有数字而无数字对应的resource和type

是否要添加type输入类型
数字代表的类型是只由resource决定还是resource和type一起决定
是否要添加type输入类型

relations_creator.py createDependAffect()方法 第7行需要修改

python中列表的index()方法：
index() 函数用于从列表中找出某个值第一个匹配项的索引位置
list.index(obj)

改的有analysis.py relatios_creator.py和relation_template_manager.py

Rendering 样式计算和布局，即重排
(Scripting)：JavaScript执行
绿色(Painting)：重绘

当浏览器接收到服务器端的页面内容之后，它需要对整个 HTML 结构进行解析，形成 DOM 树；与此同时，它还需要对相应的 CSS 文件进行解析，形成 CSS 树（CSSOM）。接下来，需要结合 DOM + CSSOM，形成一个绘制树（Render Tree）。Render 树与 DOM 很像，区别在于，它不会包含 DOM 中的 head 等与渲染内容无关的结点，也不会包含 CSS 中定义为不可见的结点（对于 CSS 中定义的伪元素，如果可见，也会出现在绘制树中）。

得到绘制树之后，需要计算每个结点在页面中的位置，这一个过程称为layout（也有的称为reflow）。值得注意的是，layout 是一个计算代价相对很大的过程，它需要从根节点进行遍历，对每个可出现在页面中的节点进行位置的计算。

由于layout的过程中，我们是在一个连续的二维平面上进行的，接下来，需要将这些结果栅格化，映射到屏幕的离散二维平面上，这一过程称为 paint。paint实际上包含了两个任务：绘制（调用底层类似于Canvas的绘制API） + 栅格化（由composite线程控制，将绘制结果上传到GPU用于组合拼装页面）。Chrome调试窗口中，实心绿色框表示绘制，空心绿色框表示的是栅格化。现代浏览器为提升性能，将页面划分多个 layer，各自进行 paint 然后组合成一个页面（composite layers）


浏览器为提升性能，将页面划分多个 layer，各自进行 paint 然后组合成一个页面（composite layers）

比较耗时的js方法
Event（js事件）里的  _showTooltipContent（echarts.js)

Animation Frame Fired 里的refreshImmediately(echarts.js)

nonzeros(a)返回数组a中值不为零的元素的下标,如果a为二维数组，返回的是一个长度为2的元组，其中它的第0个元素是数组a中值不为0的元素的第0轴的下标，第1个元素则是第1轴的下标

addhops为0时代表先找出所有的出度，出度找完后再找所有的入度
例1 <--2-->11-->12，障害点为11，addhops为0时所有关联点为11,12,2，如果有3-->2,
则关联点变为11,12,2,3（1是不在的），当addhops = 1 时，关联点是11,12,2,3,1（1是在的）

修改api以满足当输入多个点以及不满足点关系的输入时的情况

analysis_api,72行

python enumerate用法：
对于一个可迭代的（iterable）/可遍历的对象（如列表、字符串），enumerate将其组成一个索引序列，利用它可以同时获得索引和值
>>>seasons = ['Spring', 'Summer', 'Fall', 'Winter']
>>> list(enumerate(seasons))
[(0, 'Spring'), (1, 'Summer'), (2, 'Fall'), (3, 'Winter')]
print不换行 print(x,end = "")

ord()函数：
它以一个字符（长度为1的字符串）作为参数，返回对应的 ASCII 数值，或者 Unicode 数值
是chr() 函数（对于8位的ASCII字符串）或 unichr() 函数（对于Unicode对象）的配对函数
chr()函数：
chr() 用一个范围在 range（256）内的（就是0～255）整数作参数，返回一个对应的字符
>>>chr(97)
'a'
>>>ord('a')
97
列表，元组和字符串之间的相互转化：
>>> s = "xxxxx"
>>> list(s)
['x', 'x', 'x', 'x', 'x']
>>> tuple(s)
('x', 'x', 'x', 'x', 'x')
>>> tuple(list(s))
('x', 'x', 'x', 'x', 'x')
>>> list(tuple(s))
['x', 'x', 'x', 'x', 'x']
列表和元组转换为字符串则必须依靠join函数

1.访问存放template的文件夹时验证其有没有被创建
2.收集数据（collect_data()）的时候会根据conf下template文件自动生成动作model，下次修改时注意
3.relations_creator.py的storeAffect()和createRelationByJson()（根据csv文件构建动作model）中出现关于MatrixKeeper不可变的值,下次修改时注意这些地方
 
 
python2中为什么在进行类定义时最好要加object（继承object类）：
不继承object对象，只拥有了doc , module 和 自己定义的name变量, 也就是说这个类的命名空间只有三个对象可以操作.继承了object对象，拥有了好多可操作对象，这些都是类中的高级特性
不过在python 3 中已经默认就帮你加载了object了（即便你没有写上object）
Python 2.x中默认都是经典类，只有显式继承了object才是新式类
Python 3.x中默认都是新式类，不必显式的继承object
@classmethod

关于python中的集合set：相当于去掉value的字典，和字典的key一样，集合里的元素不能重复
创建空集合 s = set(),注意s = {}是创建字典
增加元素s.add()
删除元素有remove，discard，pop
remove，pop和discard的区别：
discard删除指定元素，当指定元素不存在时，不报错；
remove删除指定元素，但当指定元素不存在时，报错：KeyError。
pop删除并且返回 set “s”中的一个不确定的元素, 如果为空则引发 KeyError
remove，discard和add都只接受一个参数，pop不接受参数
同时集合还可以使用交集，并集，差集等运算: s & t;s | t;s - t

python中的dir()方法：可以查看对象内的所有属性及方法
用法 dir([]) 查看列表的方法及属性

name = 'tom'
age = 10
python格式化字符串：
print("I'm %s." %name)
python格式化字符串中含有多个参数时使用元组将值传递给模板，按照顺序对应
print("I'm %s. I'm %d year old" % (name,age))

python字符串指定字符：
strip()用于删除开始和结尾的字符，lstrip() 和 rstrip() 分别从左和从右执行删除操作，不加参数的话去除开头结尾的空格字符和换行符，如果需要删除字符串内的字符，需要用到字符串的replace方法
>>> s = ' hello     world \n'
>>> s = s.strip()
>>> s
'hello     world'
>>> s.replace(' ', '')
'helloworld'
关于python中的private，protected和public：
python中方法属性是否私有取决于它的名字，以一个下划线开头的方法为protected，可以被该类以及它的子类所访问，已两个下划线开头的方法为private，只能被本类访问
如果想访问private方法或者成员变量，可以新建一个public方法然后访问，或者在私有函数名前加上下划线和类名"_ClassName__privateMetnod"这样来访问


linux复制文件到当前目录 cp /root/redhat.txt  .
linux下压缩当前目录下所有文件及文件夹为myfile.zip
zip -r myfile.zip ./*
－r表示递归压缩子目录下所有文件.

Flask-WTF防止CSRF攻击原理：WTFforms在渲染每个表单时生成一个唯一的token,post请求时，token和
表单数据一起传递，

如何定义python函数的说明文档
在函数开头前后用三个单引号或者双引号围起来的部分可以定义自己的说明文档
函数外可以通过func.__doc__查看说明文档、

python函数调用时带括号和不带括号的区别
不带括号调用的是函数本身，
带括号（需传入需要的参数），调用的是函数的返回结果
比如需要新开一个新的线程
thread.start_new_thread(work_thread,())
其中的work_thread是你自己定义的方法，此时就不能加括号，
否则就会报TypeError: first arg must be callable
这样的错误表示第一个参数必须是可调用的

关于元组
（1，）是元组
（1）是int型 相当于1

解压文件到当前目录unzip fiename.zip

linux下构成异常分析耗时最长的解压步骤在symptom_extractor.rb文件中845行
Minitar.unpack(tgz, basename)

python中一行代码过长有两种解决办法
1，在需要换行的地方加右斜杠 '\'
2，在换行内容的前后加上圆括号
str1 = \
'bbb'
str2 = (
'bbb')
with open('a.txt') as f: 
    f.write(str)
写文件时出现io.UnsupportedOperation: not writable
是因为默认文件只有读的权限,需要加上写的权限才可以
with open('a.txt', 'w') as f
其中a.txt在不存在的时候会自动创建

extend() 函数用于在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表）
可以用来合并两个列表，a.extend(b)就将a,b两个列表合成了一个

格式化字符串可以采用%和.format两种方法
print('%s is %d'%('wang',14))
其中.format可以采用位置，关键字，下标作为参数
print("{name} is {age} years old".format(name = "wang",age = 21))
print("{0} is {1} years old".format("wang",21))
print("{1[0]} is {1[1]} years old".format(["wang",21],["li",18]))

1.点击实行后禁用其他所有按钮
2.实行的按钮名改为影響範囲探索
3.graphViz在linux上的安装顺序（待定）
4.修改折线图y轴单位（精确到小数点后一位，其中memory单位由K改为M（由原先的除以1000改成1024，除以两次，disk除一次1024）
5.graphViz的加入，以及修改
6.缺两张图的地方
7.有个instance的地方

1.main.html上添加按钮[リソース更新]
2.mainTool.js：
Line 944-970: 追加方法resourceUpdate()
3.collect_manager.py:
Line 754-763:追加方法updateResourceData()
Line 779-788:修正方法:getResourceData()
Line 55-76,121-125:修正全删除改为只删除最新的文件
4.index_pages.py:
Line 967-1002:追加方法updateresourcedata()
5.msin.css:
Line 68-85:追加弹出框式样
6.resource_manager.py:
Line 181-207:getResourceLastDay()和updateRecordFile

collect_manager.py中的run方法：
首先判断data_resource文件夹是否存在
把当前时间放进字典collectResultInfo中，key为resourceLastCollect
getResourceLastDay():从record.json中找到node对应的lastday

flask mysql

1.flask的安装
2.sqlAlchemy的安装
pip install flask-sqlalchemy
安装pymysql
pip install pymysql

新增PyMySQL库
和sqlachemy
FIAT_Visual_API版本的fiat导出后出现ImportError: No module named 'fiat'错误
fiat所在路径由FIAT_Visual_API\fiat_viusal\fiat改为FIAT_Visual_API\fiat即可

关于远程连接126上的mysql失败
sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (1045, "Access denied for user 'root'@'10.167.223.152' (using password: YES)") (Background on this error at: http://sqlalche.me/e/e3q8)
原因：是因为root账户只能在本地访问，无法远程连接
解决：新建一个普通账户并把fiat_data_db的权限都赋给它，并且开启远程连接权限
CREATE USER 'fnst'@'localhost' IDENTIFIED BY 'fnst';
grant all on fiat_data_db.* to 'fnst'@'%' identified by 'fnst' with grant option

安装 flask-sqlalchemy==2.3.2库时出现unresolved reference SQLALCHEMY
是因为导入包的问题已经由原来的from flask.ext.sqlalchemy import SQLAlchemy
改为from flask_sqlalchemy import SQLAlchemy

use fiat_data_db;使用fiat_data_db数据库
show tables; 显示fiat_data_db中的所有表
select * from original_data; 查询original_data中的所有数据
drop table original_data; 删除original_data表
desc original_data;  查看original_data表结构

Neo4j是一个图形数据库，由 Java 编写。图形数据库也就意味着它的数据并非保存在表或集合中，
而是保存为节点以及节点之间的关系。
pip install py2neo

sqlalchemy==1.2.0

检查下部署在33上的fiat问题，学习py2neo的ogm并实现在neo4j数据库上的操作

开会讨论要求，修改

查看安装包版本（以py2neo为例）：
输入python进入解释器环境
依次执行
import py2neo
py2neo.__version__

py2neo中的OGM，类似于ORM，意为 Object Graph Mapping，可以实现一个对象和 Node 的关联
利用ogm来生成节点间关系，需要先在出度类中定义比如
ownedBy = RelatedTo("Project")
然后通过自己定义的retrieveId()来获取点
最后通过a.ownedBy.add(b)来生成关系
上传到数据库graph.push(a)

查询所有

利用flask-sqlalchemy多条件查询语句：
OriginalData.query.filter_by(data_type = data_type, original_id = original_id).first()

os.path.relpath(path)
返回真实路径，例如
path=D:\FIAT1224\FIAT_Visual_API\fiat\myapi\..\orig_data\orig-00007
os.path.relpath(path)后即变成
D:\FIAT1224\FIAT_Visual_API\fiat\orig_data\orig-00007
s
fiat/__init__.py
myapi/analysis_api
dao/origindata_dao.py
controler/origindata_manager.py

python获取当前时间

vi下查找指定字符串
在命令模式下输入 /

安装jdk8
1
下载jdk8安装包
上传到linux服务器后执行
tar -xvf jdk-8u5-linux-x64.tar.gz
解压到当前目录,此时目录/usr/java
2.
添加到环境变量
vi /etc/profile
在export PATH USER LOGNAME MAIL HOSTNAME HISTSIZE HISTCONTROL下面添加如下代码：
export JAVA_HOME=/usr/local/jdk1.8.0_111
export PATH=$JAVA_HOME/bin:$PATH
export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar
3.
使配置生效
source /etc/profile

1.获取neo4j
linux下安装neo4j:
访问https://neo4j.com/download/other-releases/找到对应的neo4j的版本下载
此次安装版本是 neo4j-community-3.3.1-unix.tar.gz
2.解压
解压到当前目录
tar -zxvf neo4j-community-3.3.1-unix.tar.gz

3.开启远程访问
vi /usr/java/neo4j-community-3.3.1/conf/neo4j.conf
将 #dbms.connectors.default_listen_address=0.0.0.0 注释去掉
改为 dbms.connectors.default_listen_address=0.0.0.0
此处是开启远程访问，否则只能在本机访问neo4j数据库
4.开放端口
开放7474端口，否则还是无法远程访问
iptables -I INPUT -p tcp --dport 7474 -j ACCEPT
可以使用
/etc/init.d/iptables status
来查看端口是否开放成功
5添加环境变量
在home目录下执行
vi .bash_profile
新增一行
export PATH=/usr/java/neo4j-community-3.3.1/bin:$PATH
保存后执行
source .bash_profile
6.设置操作系统文件句柄
打开设置操作文件系统文件句柄，Neo4j默认使用的最小文件句柄是40000，而Linux操作系统一般默认是1024
vi /etc/security/limits.conf
在其中增加两行
neo4j  soft   nofile  40000
neo4j  hard   nofile  40000
主要用于索引关系比较多，或者连接关系较多的情况下
7.
启动neo4j
/usr/java/neo4j-community-3.3.1/bin/neo4j start



 cat /etc/issue
 查看当前系统版本
sqlalchemy.exc.InvalidRequestError: Object '<>' is already attached to sessi

from fiat.model.origin_data import db

python 列表的赋值，浅拷贝和深拷贝
以列表的复制为例
"="赋值是达不到复制的效果的,a = b，只是代表他们指向同一片内存，修改a的同时b也会发生变化
赋值操作（包括对象作为参数、返回值）不会开辟新的内存空间，它只是复制了新对象的引用
浅拷贝：浅拷贝会创建新对象，其内容是原对象的引用。
b = a[:]  切片
b = list(a) 工厂函数
b = copy.copy(a)  copy函数
不过浅拷贝只是拷贝了一层，如果a中有嵌套列表，修改嵌套列表的话，浅拷贝的b也会发生变化
深拷贝：
b = copy.deepcopy(a)
拷贝了所有，包含多层嵌套的元素，生成了一个全新的对象
需注意：
1.对于非容器类型，如数字，字符，以及其它“原子”类型，没有拷贝一说。产生的都是原对象的引用。。
2、如果元组变量值包含原子类型对象，即使采用了深拷贝，也只能得到浅拷贝


要复制列表的话，使用切片的方式，b=a[:]
2.
查看变量内存地址
id(a)

后期绑定 ，闭包
ruby列表切片和python 不同，使用a[1,5]


6

ruby中将字符串转化成数组的几种方法
以字符串"games,fun,sports"为例

1.可以使用split(',')转化成数组
"games,fun,sports".split(',') # => ["games", "fun", "sports"]

2.如果是JSON格式的字符串，例如'["games", "fun", "sports"]'
'["games", "fun", "sports"]'.split(',') # =>
 ["[\"games\"", " \"fun\"", " \"sports\"]"]
 不是我们想要的结果
 此时可以使用json库来格式化字符串
只需要
require 'json'
JSON['["games", "fun", "sports"]'] # => ["games", "fun", "sports"]
即可
原文是来自stackoverflow的问题
原文链接https://stackoverflow.com/questions/39337794/how-to-convert-a-string-to-an-array-using-ruby-on-rails

array = array.uniq
uniq method删除所有重复的元素，并保留数组中的所有唯一元素。

c++ 中：：可表示全局作用域符号
int i=10;
int main(){
	int i=20,j=7;
	cout<<i+::i%c;
	return 0;
}
输出结果是23

http://blog.csdn.net/huilan_same/article/details/52944782

python元组介绍
1.python元组和列表类似，不同的是元组里的元素无法修改
2.创建一个空元组：
tuple_a = ()或者tuple_a = tuple()
3.元组的访问
和列表相同，使用下标索引来访问元组的值，索引和截取也和列表一样
也可以使用len(),max(),min()等函数；列表转化成元组，使用tuple(list)
>>>a = (3,4,5,6)
>>>a[3]
6

4.元组的修改
上面说了，元组和列表类似，不同的是元组里的元素无法修改，
虽然无法修改，但是可以进行连接组合，可以使用"+"和"*"运算符
>>> a = (3,4)
>>> b = (7,9)
>>> a = a + b
>>> a
(3, 4, 7, 9)
5.元组的删除
元组无法删除里面的单个值，只能通过del来删除整个元组，下面代表a已被删除，访问a会出错
>>> a
(3, 4, 7, 9)
>>> del a
>>> a
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
NameError: name 'a' is not defined
###注意：
元组中只包含一个元素时，需要在元素后面添加逗号，否则括号会被当作运算符使用：
>>> tup1 = (50)
>>> type(tup1)     # 不加逗号，类型为整型
<class 'int'>

>>> tup1 = (50,)
>>> type(tup1)     # 加上逗号，类型为元组
<class 'tuple'>

python中元组和列表的异同：
相同的地方：
1.创建方式类似
元组： t = ()或者 t = tuple()
列表： a = []或者 a = list()
2.访问方式
均可以使用索引或者截取
t=(2,3,5)  #>> t[2]输出为5
a=[2,3,5]  #>> a[2]输出为5
3.内置函数部分相同
len();count();max();min();index(value)
4.删除方式相同：
del tuple_a
del list_a
5.和字符串相似，均可以使用 + 和 * 操作符

不同的地方：
元组没有append(),insert(index,obj),pop(),remove()等方法；
主要是由于元组不可改变的性质决定的，

注意：tuple元素不可变有一种特殊情况，当元素是可变对象时。对象内部属性是可以修改的；
比如元组里有列表或者字典等，此时列表和字典是可以改变的

python函数参数不带*， * 和 ** 的区别
以func(positional_args, keyword_args,*tuple_grp_nonkw_args, **dict_grp_kw_args)为例
func就包含四种参数
#positional_args方式
>>> test(1,2,3,4,5)
1 2 3 4 5
#这种调用方式的函数处理等价于
a,b,c,d,e = 1,2,3,4,5
print a,b,c,d,e

#keyword_args方式
>>> test(a=1,b=3,c=4,d=2,e=1)
1 3 4 2 1

def tupleArgs(*targs):
    print(targs)
    for i in targs:
        print(i)
tupleArgs('a','b','c')
输出是
('a', 'b', 'c')
a
b
c
也可以运行
def tupleArgs(**targs):
    print(targs)
    for i in targs:
        print(i)

tupleArgs(q='a',w='b',e='c')
输出
{'q': 'a', 'e': 'c', 'w': 'b'}
q
e
w

*arg 和 **arg可以不传递参数

python3列表常用操作
remove() 函数用于移除列表中某个值的第一个匹配项
>>> a = [3,3,2,2]
>>> a.remove(3)
>>> a
[3, 2, 2]

删除全部列表内指定元素
while i in list_a:
    list_a.remove(i)
即可

根据索引删除元素
del list_a[index]

>>> a
[3, 2]
>>> del a[0]
>>> a
[2]

关于可变对象的赋值，浅拷贝和深拷贝
python中list ,dict为可变对象，int,string,float,tuple为不可变对象
简单地赋值的话
list_b = list_a
修改list_a的同时list_b也会发生改变

使用浅拷贝的话list_b就不会发生改变（在自身内部没有可变情况的情况下）
使用浅拷贝
list_b = list_a.copy()或者
import copy
list_b = copy.copy(list_a)

若list_a内有可变对象元素的话，若此时这个可变元素对象发生改变，则浅拷贝的list_b
也会变化，
此时我们可以采用深拷贝来避免这种情况
import copy
list_b = copy.deepcopy(list_a)

python中的编码和解码
python3中文本总是Unicode,由str类型进行表示，
二进制数据使用bytes进行表示
字符串通过编码成为字节码，字节码通过解码成为字符串。
str类型编码采用encode()方法编码
str.encode()，可以接受参数表明编码方式
str.encode('utf-8')
bytes类型采用decode()方法解码，
bytes.decode()同样可以接受参数表明解码方式
bytes.decode('utf-8')
不加参数的话，默认采用utf-8编码和解码
官方文档
https://docs.python.org/3/library/stdtypes.html?highlight=decode#str.encode
https://docs.python.org/3/library/stdtypes.html?highlight=decode#bytes.decode

python中的'\x'代表后面的字符是十六进制位
比如'\xaa'就相当于chr(0xaa)
'\xaa'是一个Unicode字符串
官方文档：
https://docs.python.org/3/reference/lexical_analysis.html#string-and-bytes-literals

pytyon内存管理机制：
Python GC主要使用引用计数（reference counting）来跟踪和回收垃圾。在引用计数的基础上，通过“标记-清除”（mark and sweep）解决容器对象可能产生的循环引用问题，通过“分代回收”（generation collection）以空间换时间的方法提高垃圾回收效率。

python assert用法
assert condition, AssertionErrorString
举例
assert 2>5, '2 is less than 5'
执行的话就会打出错误信息'2 is less than 5'

python中的@property
使用@property可以使我们的函数像属性一样被使用，具体使用方法：

class Grades:
    @property
    def score(self):
        return self.scoreValue

    @score.setter
    def score(self,value):
        if not isinstance(value, int):
            raise ValueError('Input must be a Integer')
        if value<0 or value>100:
            raise ValueError('Input must between 1~100')
        self.scoreValue = value

g = Grades()
g.score = 7
print(g.score)
可以看出，我们可以像使用属性一样来使用函数，不过注意scoreValue不能写成score，除此之外的都可以，
推荐写成私有变量  _score 的形式，这里为了便于理解只写成了scoreValue

那为什么我们要使用它以及什么时候应该使用它呢
请看官方解释https://www.programiz.com/python-programming/property的
译文在这http://python.jobbole.com/81967/

计算斐波那契数列的两种方法，递归和迭代
def fib_recursion(n):
    assert n>=0, 'Parameter must be a positive integer'
    if n <= 1:
        return n
    else:
        return fib_recursion(n-1) + fib_recursion(n-2)

def fib_iteration(n):
    assert n>0, 'Parameter must be a positive integer'
    a,b=0,1
    for i in range(n):
        a,b =b,a+b
    return a


print(fib_iteration(10))
print(fib_recursion(10))


修正场所： //modify FIATV2.2 start //modify FIATV2.2 end 差分数据取得： 1.main.html上添加按钮[リソース更新] 

2.mainTool.js： Line 944-970: 追加方法resourceUpdate() 

3.collect_manager.py: Line 754-763:追加方法updateResourceData() Line 779-788:修正方法:getResourceData() Line 55-76,121-125:修正全删除改为只删除最新的文件 Line 313-355,362-381,401-429：自动取得数据部分修改成只取差分数据 

4.index_pages.py: Line 967-1002:追加方法updateresourcedata() 

5.msin.css: Line 68-85:追加弹出框式样 

6.resource_manager.py: Line 181-207:getResourceLastDay()和updateRecordFile() 追加record.json文件名配置项： 

1.model_constructor.conf:RECORD_FILE = record.json 

2.build_config.py:Line 49 

自动取得时间设定复数： 

1.admin_pages.py: Line 181-191,96-100,524-527 

2.collect_manager.py: Line 258-267 collect时默认取30天数据 

王： relations_creator.py 19-24 导入graphViz库 668 修改genAffectResult的返回结果 679-772 利用graphViz获取点的坐标 

maintool.js 

110-114 根据点的数量确定点的大小 

163-173 给点的信息增加x,y坐标 

389-466 增加drawLineChart方法，防止图画好前用户点击 

582-590 判断params是不是array的instance ->有两处 

691-698 画cpu折线图时小数点精确到一位 ->有两处 

750-1120 根据titleName来判断是不是MEM，把MEM的y轴坐标改为MB 

1165和1200 增加drawLineChart 

1171和1205 改变适用颜色 ->应该是改变通过点click触发后，画折线图后，CPU,DAY按钮变红 main.html 

130-133 点击影响范围探索按钮时时禁用影响范围一览表示和影响范围download按钮 ->禁用方法是否会有问题？ 

214-222 修改点击右边七个按钮时触发的方法 

246 修改展示折线图时只展示一天内的数据 

271 增加drawLineChart方法 

511-524 根据title是不是MEM来决定y轴单位 

612-706 点击影响范围按钮时禁用cpu，mem等按钮 index_pages 55,修改实行为影响范围探索 添加全数据取得按钮: 

1.admin_pages.py: Line 107：添加按钮 Line 255-275：对应全数据取得按钮的响应事件 

2.collect.html Line 61,76-80:追加全数据取得按钮以及JS方法 

3.collect_manager.py Line 174-249:追加collectAllResourceData（）方法，获取全数据 

Line 1144-1246:追加collectAllData()方法，用于获取全数据
(11:45:40) zhangch-fnst: F:\AnalysisLog_SVN\06.20170106\01.フィルタ生成改良\01.SD\フィルタ生成改良_V2.0_詳細仕様書.docx
(11:45:55) zhangch-fnst: F:\AnalysisLog_SVN\06.20170106\05.障害影響分析ツールV02.1\03.SD\障害影響分析ツールv02_詳細仕様書.docx

(15:39) zhangch-fnst: 例えば：
従来の学習結果に001-0205-0149、001-0625-0840があります。
新しいの学習を実行する時、incidentsフォルダに001-0625-0840、004-0127-1033があります。

そのため、マージ後output_cases.csvに001-0205-0149、001-0625-0840、004-0127-1033　
3つQQMがあれば、学習結果が正しくマージされると思います。

(17:40) zhangch-fnst: 0.Bug fix:服务异常中断后lock文件无法删除；node名中包含/时生成的文件有误
修正场所：
    __init__.py:Line 21-27
	collect_manager.py:Line550,564,594,610-611,697-698
	resource_manager.py:Line 75
	matrix_keeper.py:Line41,42
	relations_creator.py:Line 593
(17:40) zhangch-fnst: img下缺两张图片：glyphicons-halflings.png和glyphicons-halflings-white.png
(17:40) zhangch-fnst: mainTool.js bug:instanceof
修正场所：
    Line 511
	Line1071-1082

python获取随机数
import random
#获取0到1之间的随机小数
random.random()
#获取指定范围a到b之间的随机小数
random.uniform(a,b)
#获取指定范围a到b之间的随机整数,包含a,b
random.randint(a,b)
#随机获取列表里的一个值
random.choice(list_a)

(17:37) zhangch-fnst: collectUrl = "http://10.25.212.33:8081/v1/getAllOriginJsonFilePath"
(17:38) zhangch-fnst: requests.get(self.collectUrl, auth=("apiuser", "fnst1234"))

关于本次SD书写收获：
关于格式：
1.确定大纲结构，包括章节目录等
2.按照一定规则来说明，比如可以先说明后端修改内容，然后再说明前端修改内容
3.对目录及其子目录要有一定的总括说明，包括该目录下修改的概括以及原因
4.对目录下的各个条目要有一定的说明，包括修改的场合以及具体内容
5.关于图片的放置位置，应该放置在每个主目录说明之后，标上序号并加以说明
关于内容：
1.为方便阅读，各个章节用语应当统一，比如｢データ取得」、「データ収集」等意思相近的应当统一用一个词来说明
2.各个条目中的详细说明中对于修改代码应以显著颜色标注，为阐明重点内容，无用注释须去掉
3.为便于理解，对于修改的地方应予以说明，包括修改原因，修改内容，修改后的效果等
4.为便于日后查阅，对于修改地方的说明，应具体到所在文件下的所在类下的具体方法

字典中验证key是否存在，python2中使用has_key()函数，
不过在python3.x版本中已不包含has_key(),
被__contains__(key)替代

region_template_manager.py新增一行
getDataConf["OpenStackMethods"] = region["OpenStackMethods"]
region_all.json新增一行"OpenStackMethods":"password",

python rsplit()和split()区别是
rsplit()从右边开始分割
split()从左边开始分割

# Writing JSON data 将data写入到data.json文件中
with open('data.json', 'w') as f:
    json.dump(data, f)
# Reading data back 将data.json中数据取出放到data.json里
with open('data.json', 'r') as f:
    data = json.load(f)
python中loads()和load()的区别
loads()操作的是字符串，将str转化成字典
load()的操作与文件有关
dumps()操作的是字典，将字典转化成str
dump()操作也是与文件有关

linux下强制结束进程
kill -s 9 11533
其中11533为进程id
可以用来模拟意外情况关闭进程

格式化字符串可以使用str.format()
使用{}来代替%
方法：
1.通过 位置
In [1]: '{0},{1}'.format('kzc',18) 
Out[1]: 'kzc,18'
2.通过关键字参数
In [5]: '{name},{age}'.format(age=18,name='kzc') 
Out[5]: 'kzc,18'

NGの原因:offline.htmlのisCommitted変数を定義しない,影響範囲図のnodeをクリックする場合、折れ線グラフを表示しない

创建新的元组也可以不使用括号，不过要使用逗号将值分开
>>> a = 3,6
>>> type(a)
<class 'tuple'>
>>> a
(3, 6)
>>>

关于Pycharm中代码无错误同时运行正常却出现unresolved reference错误的原因
主要是项目根目录路径设置不对
解决办法：在Pycharm项目视图中右击根目录文件夹
在菜单中选择 Mark Directory As > Source Root 即可

Python中的内存管理机制
1.变量，对象，引用，内存缓冲区
要理解Python中的内存管理机制，首先要对变量，对象，引用，内存缓冲区概念有个大致的理解。
以a=1为例，其中a是变量，1是对象，a同时是一个引用，指向对象1
Python中的变量本身是没有类型的，它的类型决定于它所指向的对象的类型，
此时a=1,a的对象是int,如果接下来执行a=1.5，它的类型就变成float了。
和C++中的引用不同，Python中的引用可以随时修改指向对象，而C++中
引用一旦初始化就无法修改了。
一个对象可以有多个变量指向它，比如再定义b=1,此时b也是对象1的引用
缓冲区：
Python在解释器启动的时候会预先分配好一些缓冲区，这些缓冲区的内存地址是固定的（在
一次程序启动之后），比如一次程序启动后在[-5,256]之间的整数的内存地址是固定的

#第一次启动解释器
>>> hex(id(1))
'0x5d9801f0'
>>> hex(id(2))
'0x5e04c860'

#第二次启动解释器
>>> hex(id(1))
'0x5d98c840'
>>> hex(id(2))
'0x5d980210'
>>> hex(id(300))
'0x2672ed0'
>>> hex(id(300000))
'0x2672ed0'
>>> hex(id(30000000))
'0x2672ed0'
对整数对象内存的存储，主要分为两个区，[-5,256]小整数缓冲区池的整数是程序启动后
事先分配好的，属于静态分配，变量赋值直接从里面取就行。程序启动一次后，[-5,256]中每个整数对象
都有自己的内存地址，且在Python程序结束前地址不会发生变化。而[-5,256]之外的整数缓冲池被称为大整数缓冲池，
这块内存也是分配好的，只是要用的时候再分配内存，比如下面257这个数字，
虽然给a和b赋了相同的值，但是解释器实际上是先分配了不同的地址，再把这个地址给两个变量。
>>> a = 1
>>> b = 1
>>> hex(id(a))
'0xe17158'
>>> hex(id(b))
'0xe17158'
>>> b = 257
>>> a = 257
>>> hex(id(a))
'0xe5be00'
>>> hex(id(b))
'0xe5bdd0'

2.垃圾回收
现在的主流语言基本都支持三种最基本的内存分配方式:

A）静态分配，如静态变量、全剧变量，通常这一部分内存不需要释放或者回收；

B）自动分配，通常由语言或者编译器控制，如栈中局部变量、参数传递；

C）动态分配，这部分通常在栈中分配，由用户申请。

垃圾收集机制就是用来处理程序动态分配内存时产生的垃圾
python垃圾回收以引用计数为主，标记-清除和分代收集为辅。
我们知道，Python是用C语言写的，底层内存的分配和释放也是通过malloc和free进行的，不过是Python自动决定
何时分配释放的，不过同时提供接口让用户手动释放，它本身有自己的一套内存管理体系，主要通过两种机制来实现，
一个是引用计数，一个是垃圾回收。
前者负责确定当前变量是否需要释放，后者解决前者解决不了的循环引用问题以及提供手动释放的接口。

引用计数：针对可以重复利用的内存缓冲区和内存，python使用了一种引用计数的方式来控制和判断某快内存是否已经没有再被使用。
即每个对象都有一个计数器count，记住了有多少个变量指向这个对象，当这个对象的引用计数器为0时，
假如这个对象在缓冲区内，那么它地址空间不会被释放，而是等待下一次被使用，而非缓冲区的该释放就释放。
这里通过sys包中的getrefcount()来获取当前对象有多少个引用。这里返回的引用个数分别是2和3，
比预计的1和2多了一个，这是因为传递参数给getrefcount的时候产生了一个临时引用[1]。
>>> a = []
>>> getrefcount(a)
2
>>> b = a
>>> getrefcount(a)
3

引用计数最大缺陷就是循环引用的问题。什么是循环引用？A和B相互引用而再没有外部引用A与B中的任何一个，它们的引用计数虽然都为1，但显然应该被回收，例子：

a = { } # a 的引用为 1
b = { } # b 的引用为 1
a['b'] = b # b 的引用增 1，b的引用为2
b['a'] = a # a 的引用增 1，a的引用为 2
del a # a 的引用减 1，a的引用为 1
del b # b 的引用减 1, b的引用为 1
在这个例子中,del语句减少了 a 和 b 的引用计数并删除了用于引用的变量名，
可是由于两个对象各包含一个对方对象的引用，虽然最后两个对象都无法通过名字访问了，
但引用计数并没有减少到零。因此这个对象不会被销毁，它会一直驻留在内存中，
这就造成了内存泄漏。为了解决循环引用问题，Python引入了标记-清除和分代回收两种GC机制。

#https://github.com/Hipponensis/Notes/blob/master/%E5%85%B3%E4%BA%8EPython%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6.md
#https://chenrudan.github.io/blog/2016/04/23/pythonmemorycontrol.html

linux下源码安装django
源码安装方法
下载源码包：https://www.djangoproject.com/download/

输入以下命令并安装：

tar xzvf Django-X.Y.tar.gz    # 解压下载包
cd Django-X.Y                 # 进入 Django 目录
python setup.py install       # 执行安装命令


github上下载源码解压后
python setup.py install

linux上解压zip文件到saveDir文件夹
unzip file.zip -d saveDir


#https://stackoverflow.com/questions/18546299/setting-up-django-with-uwsgi-and-nginx
uwsgi --http :8000 --module mysite.wsgi
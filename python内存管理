Python中的内存管理机制
1.变量，对象，引用，内存缓冲区
要理解Python中的内存管理机制，首先要对变量，对象，引用，内存缓冲区概念有个大致的理解。
以a=1为例，其中a是变量，1是对象，a同时是一个引用，指向对象1
Python中的变量本身是没有类型的，它的类型决定于它所指向的对象的类型，
此时a=1,a的对象是int,如果接下来执行a=1.5，它的类型就变成float了。
和C++中的引用不同，Python中的引用可以随时修改指向对象，而C++中
引用一旦初始化就无法修改了。
一个对象可以有多个变量指向它，比如再定义b=1,此时b也是对象1的引用
缓冲区：
Python在解释器启动的时候会预先分配好一些缓冲区，这些缓冲区的内存地址是固定的（在
一次程序启动之后），比如一次程序启动后在[-5,256]之间的整数的内存地址是固定的

#第一次启动解释器
>>> hex(id(1))
'0x5d9801f0'
>>> hex(id(2))
'0x5e04c860'

#第二次启动解释器
>>> hex(id(1))
'0x5d98c840'
>>> hex(id(2))
'0x5d980210'
>>> hex(id(300))
'0x2672ed0'
>>> hex(id(300000))
'0x2672ed0'
>>> hex(id(30000000))
'0x2672ed0'
对整数对象内存的存储，主要分为两个区，[-5,256]小整数缓冲区池的整数是程序启动后
事先分配好的，属于静态分配，变量赋值直接从里面取就行。程序启动一次后，[-5,256]中每个整数对象
都有自己的内存地址，且在Python程序结束前地址不会发生变化。而[-5,256]之外的整数缓冲池被称为大整数缓冲池，
这块内存也是分配好的，只是要用的时候再分配内存，比如下面257这个数字，
虽然给a和b赋了相同的值，但是解释器实际上是先分配了不同的地址，再把这个地址给两个变量。
>>> a = 1
>>> b = 1
>>> hex(id(a))
'0xe17158'
>>> hex(id(b))
'0xe17158'
>>> b = 257
>>> a = 257
>>> hex(id(a))
'0xe5be00'
>>> hex(id(b))
'0xe5bdd0'

2.垃圾回收
现在的主流语言基本都支持三种最基本的内存分配方式:

A）静态分配，如静态变量、全剧变量，通常这一部分内存不需要释放或者回收；

B）自动分配，通常由语言或者编译器控制，如栈中局部变量、参数传递；

C）动态分配，这部分通常在栈中分配，由用户申请。

垃圾收集机制就是用来处理程序动态分配内存时产生的垃圾
python垃圾回收以引用计数为主，标记-清除和分代收集为辅。
我们知道，Python是用C语言写的，底层内存的分配和释放也是通过malloc和free进行的，不过是Python自动决定
何时分配释放的，不过同时提供接口让用户手动释放，它本身有自己的一套内存管理体系，主要通过两种机制来实现，
一个是引用计数，一个是垃圾回收。
前者负责确定当前变量是否需要释放，后者解决前者解决不了的循环引用问题以及提供手动释放的接口。

引用计数：针对可以重复利用的内存缓冲区和内存，python使用了一种引用计数的方式来控制和判断某快内存是否已经没有再被使用。
即每个对象都有一个计数器count，记住了有多少个变量指向这个对象，当这个对象的引用计数器为0时，
假如这个对象在缓冲区内，那么它地址空间不会被释放，而是等待下一次被使用，而非缓冲区的该释放就释放。
这里通过sys包中的getrefcount()来获取当前对象有多少个引用。这里返回的引用个数分别是2和3，
比预计的1和2多了一个，这是因为传递参数给getrefcount的时候产生了一个临时引用[1]。
>>> a = []
>>> getrefcount(a)
2
>>> b = a
>>> getrefcount(a)
3

引用计数最大缺陷就是循环引用的问题。什么是循环引用？A和B相互引用而再没有外部引用A与B中的任何一个，它们的引用计数虽然都为1，但显然应该被回收，例子：

a = { } # a 的引用为 1
b = { } # b 的引用为 1
a['b'] = b # b 的引用增 1，b的引用为2
b['a'] = a # a 的引用增 1，a的引用为 2
del a # a 的引用减 1，a的引用为 1
del b # b 的引用减 1, b的引用为 1
在这个例子中,del语句减少了 a 和 b 的引用计数并删除了用于引用的变量名，
可是由于两个对象各包含一个对方对象的引用，虽然最后两个对象都无法通过名字访问了，
但引用计数并没有减少到零。因此这个对象不会被销毁，它会一直驻留在内存中，
这就造成了内存泄漏。为了解决循环引用问题，Python引入了标记-清除和分代回收两种GC机制。

#https://github.com/Hipponensis/Notes/blob/master/%E5%85%B3%E4%BA%8EPython%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6.md
#https://chenrudan.github.io/blog/2016/04/23/pythonmemorycontrol.html
